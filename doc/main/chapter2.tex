\chapter{Gröbner Bases}

This chapter provides a concise introduction to Gröbner bases and Buchberger's algorithm. The discussion is tailored for an audience of beginning graduate students or advanced undergraduates in mathematics and computer science. Accordingly, we assume a familiarity with standard undergraduate curricula, like calculus and linear algebra, but while a background in abstract algebra, commutative algebra, or algebraic geometry is advantageous, it is not a prerequisite for following the exposition provided here. No original work presented.

For those seeking a more comprehensive treatment, the first two chapters of \cite{cox2015_IVA} offer an excellent and widely recognized alternative introduction. Additional foundational perspectives can be found in \cite{cox2005_UAG, Kreuzer2000_CAG, Sturmfels2005_WhatIsGB}, while \cite{Adams1994_IGB} provides a more advanced theoretical framework. From a historical perspective, this work draws upon Bruno Buchberger's seminal doctoral thesis \cite{Buchberger1965_algorithmGerman, Buchberger1965_algorithmEnglish} and his subsequent survey \cite{Buchberger1985_SurveyArticle}. We also acknowledge modern optimizations that have fundamentally shaped the efficiency of the algorithm, such as the work of \cite{Gebauer1988_InstallationOfGB, Giovini1991_OneSugarCube, Sun2011_F5InBuchbergersStyle}, which are well contextualized among other relevant works in the introductory material of \cite{Eder2012_SignatureBasedAlgorithms}.

The primary objective of this chapter is to establish an understanding of Buchberger's algorithm, with a particular emphasis on the role that $S$-pair selection strategies play in its computational performance. As the ultimate goal of this thesis is to leverage machine learning to optimize these selection processes, establishing this mathematical foundation is a critical first step.

\section{Polynomial Rings and Ideals}

The study of systems of multivariate polynomial equations is a cornerstone of both computational algebra and algebraic geometry. Consider a typical system of equations
\begin{equation}
\label{eq:system1}
\begin{cases}
    \ f_{1}(x,y) = x^{2} - y^{3} = 0\\
    \ f_{2}(x,y) = x^{2} - 4y + 3 = 0
\end{cases}
\end{equation} \\
which arise naturally across many diverse fields, like robotics \cite{usage_robotics1}, signal processing \cite{usage_signalprocessing1}, and statistics \cite{usage_stats1,usage_stats2}. The most fundamental question regarding such a system is the \textit{consistency} problem, which asks whether there exists an exact common solution $(x_0, y_0) \in \mathbb{C}^2$ such that all equations are simultaneously satisfied.

To approach this problem algebraically, we work within a formal structure known as a polynomial ring.

\begin{definition}[Polynomial Ring]
\label{def:poly_ring}
The polynomial ring $R = k[x_1, \dots, x_n]$ is the set of all polynomials in variables $x_1, \dots, x_n$ with coefficients from a field $k$ (typically $\mathbb{Q}, \mathbb{R},$ or $\mathbb{C}$). $R$ is an associative algebra equipped with standard addition and multiplication operations for polynomials.
\end{definition}

One powerful way to show that a system has no solution is to find a contradiction through a linear combination of its generators. If we can find polynomials $a_1, a_2 \in R$ such that:
\begin{equation}
\label{eq:combination}
a_{1}(x,y)f_{1}(x,y) + a_{2}(x,y)f_{2}(x,y) = 1,
\end{equation}
then the system must be inconsistent. Indeed, any hypothetical solution $(x_0, y_0)$ would force the left-hand side of (\ref{eq:combination}) to zero, contradicting the fact that the right-hand side is the constant $1$. According to Hilbert's Nullstellensatz, over an algebraically closed field like $\mathbb{C}$, the converse is also true; as in, a system has no common zeros if and only if $1$ can be expressed as a polynomial combination of the generators.

This observation shifts our focus from the equations themselves to the set of all possible polynomial combinations they can generate. This set is known as an ideal.

\begin{definition}[Ideal]
\label{def:ideal}
Let $f_1, \dots, f_s$ be polynomials in $R$. The ideal generated by these polynomials, denoted $\langle f_1, \dots, f_s \rangle$, is the set
\begin{equation}
\langle f_1, \dots, f_s \rangle = \left\{ \sum_{i=1}^{s} a_i f_i \mid a_i \in R \right\}.
\end{equation}
\end{definition}

Algebraically, an ideal is a sub-module of $R$ that is closed under addition and under multiplication by any element of $R$. Conceptually, an ideal $I$ represents the collection of all polynomial consequences of its generators; if a point is a zero for every generator of $I$, it is necessarily a zero for every polynomial in $I$.

The consistency of the system in (\ref{eq:system1}) is therefore equivalent to the ideal membership problem; determining whether the constant polynomial $1$ lies within the ideal $I = \langle x^{2} - y^{3}, x^{2} - 4y + 3 \rangle$. While it may not be immediately obvious for this specific example, the system (\ref{eq:system1}) does in fact possess solutions (for instance, $(-1, 1)$), meaning $1 \notin I$. We could easily imagine more complex systems of polynomial equations, where assessing membership is far less straightforward. Thus, developing a systematic algorithmic test for such membership is the primary motivation for the theory of Gröbner bases.

\section{Multivariate Division}

In the previous section, we established that the solvability of a system of polynomial equations reduces to the ideal membership problem, which states, given a polynomial $f$ and an ideal $I = \langle f_1, \dots, f_s \rangle$, is $f \in I$?

In the univariate case, where $R = k[x]$, this problem is trivialized by the Euclidean division algorithm. Since $k[x]$ is a principal ideal domain, any ideal is generated by a single greatest common divisor, say $g$. To check if $f \in \langle g \rangle$, one simply computes the remainder of $f$ divided by $g$. If the remainder is $0$, then $f \in I$; otherwise, it is not. Let's illustrate this with a simple example.

\begin{example}
\label{ex:univar_membership}
Consider the ideal $I = \langle x^2 - x \rangle$ in $\mathbb{Q}[x]$, and lets check if $h_1(x) = x^3 - x^2$ and $h_2(x) = x^3 - 1$ are elements of $I$. Dividing $h_1$ by $x^2 - x$ using polynomial long division 
\[
x^3 - x^2 = (x)(x^2 - x) + 0
\]
yields a remainder of $0$, confirming that $h_1 \in I$. Conversely, for $h_2$, we have
\[
x^3 - 1 = (x + 1)(x^2 - x) + (x - 1)
\]
with a non-zero remainder of $x - 1$, indicating that $h_2 \notin I$. This is a direct and trivial application of the division algorithm in one variable.
\end{example}

However, generalizing this logic to the multivariate ring $k[x_1, \dots, x_n]$ introduces complications. Consider another example.

\begin{example} 
\label{ex:multivar_membership}
Let $I = \langle x^2 y - x, x^2 + y^3 \rangle$ in the ring $\mathbb{Q}[x, y]$, and let's check if $h_3(x, y) = x^2y + y^4$ is an element of $I$. Here, $I$ is generated by two polynomials, its elements can be expressed as combinations of the generators: $a_1(x^2 y - x) + a_2(x^2 + y^3)$ for some $a_1, a_2 \in \mathbb{Q}[x, y]$. This example follows the same principle as before, but considering that $a_1$ and $a_2$ can be any polynomials in two variables, the search space is vastly larger. Other than impractical trial and error, there is no straightforward method to determine if such $a_1$ and $a_2$ exist that satisfy the equation $h_3 = a_1(x^2 y - x) + a_2(x^2 + y^3)$.
\end{example}

Our goal is to apply our solution for Example \ref{ex:univar_membership} to Example \ref{ex:multivar_membership} by developing a multivariate division algorithm. However, two main issues arise in this generalization.

Firstly, in Example \ref{ex:univar_membership}, there only exists one polynomial divisor to be used in the division algorithm, but in Example \ref{ex:multivar_membership}, there are two generators in the ideal, leading to multiple possible divisors to choose from at each step. We can overcome this problem by simply choosing one of the divisors in each step and keeping track of a quotient for each divisor. The final result in the univariate case is expressed as $f = aq + r$, where $a$ is the quotient, $q$ is the divisor, and $r$ is the remainder. In the multivariate case with multiple divisors, we can express the result as $f = a_1 q_1 + \dots + a_s q_s + r$, where each $a_i$ is the quotient corresponding to divisor $q_i$. This expression still captures the essence of the division algorithm, but now accommodates multiple divisors.

Secondly, notice that in the division algorithm we divide the leading term of the dividend by the leading term of the divisor, giving importance to what we consider the leading term, or the largest term in a polynomial. In the univariate case, this is straightforward since there is a natural ordering of terms by degree ($x^2 > x$). In the multivariate case, however, there is no inherent way to order terms like $x^2 y$ and $x y^2$. To address this, we need to follow a systematic rule for ordering monomials in multiple variables to ensure consistency in determining leading terms. We denote a monomial $x_1^{\alpha_1} \dots x_n^{\alpha_n}$ as $x^\alpha$, where $\alpha \in \mathbb{Z}_{\ge 0}^n$.

\begin{definition}[Monomial Ordering]
\label{def:monomial_ordering}
A monomial ordering on $k[x_1, \dots, x_n]$ is a relation $>$ on the set of monomials such that $>$ is a total ordering (any two monomials are comparable), $>$ is compatible with multiplication, as in, if $x^\alpha > x^\beta$, then $x^\alpha x^\gamma > x^\beta x^\gamma$ for all $\gamma$, and $>$ is a well-ordering (every non-empty set of monomials has a least element).
\end{definition}

The conditions of monomial ordering are set to guarantee consistency and termination of the division algorithm. The total ordering condition ensures that we can always identify a leading term in any polynomial. The compatibility condition guarantees that the ordering behaves predictably under multiplication, and the well-ordering condition is specially critical for computer science applications, as it guarantees that any algorithm reducing the size of a polynomial based on this order will eventually terminate. While there are infinitely many such orderings, two are very frequently used in computational algebra; lexicographic order (lex) and graded reverse lexicographic order (grevlex).

\begin{definition}[Lexicographic Order]
\label{def:lex_order}
Let $\alpha, \beta \in \mathbb{Z}_{\ge 0}^n$. The lexicographic order is defined by  $x^\alpha >_{lex} x^\beta$ if the leftmost non-zero entry of the vector difference $\alpha - \beta$ is positive.
\end{definition}
Intuitively, Lex behaves like a dictionary sort. For variables $x > y > z$, we have $x > y^5 z^3$ because the $x$-exponent dominates. On the other hand, $y^5 z^3 > y^4 z^{10}$ because the $y$-exponent is larger.

\begin{definition}[Graded Reverse Lexicographic Order]
\label{def:grevlex_order}
Graded reverse lexicographic order is defined by $x^\alpha >_{grevlex} x^\beta$ if $|\alpha| > |\beta|$, or if $|\alpha| = |\beta|$ and the rightmost non-zero entry of $\alpha - \beta$ is negative.
\end{definition}
Grevlex compares total degree first. For example, $x>y>z$, $y^2 > x z$ since $2 > 1$. If total degrees are equal, it favors monomials that have fewer variables from the end of the ordering. Thus, $x y > x z$ because the $y$-exponent is larger than the $z$-exponent. For computation, grevlex is often more efficient than lex as it tends to keep coefficients smaller.

With a fixed monomial order, we can define the leading term of a polynomial $f$, denoted $\text{LT}(f)$, as well as its coefficient $\text{LC}(f)$ and monomial $\text{LM}(f)$.

Given a monomial order and a set of divisors $F = \{f_1, \dots, f_s\}$, we can formulate a multivariate polynomial long division algorithm with the goal to write $f$ as
\[ f = a_1 f_1 + \dots + a_s f_s + r \]
where no term in the remainder $r$ is divisible by any $\text{LT}(f_i)$. Algorithm \ref{alg:mult_polydivision} outlines this process.

\begin{definition}[Reduction]
\label{def:reduction}
When a polynomial $h$ is divided by a set of polynomials $F = \{f_1, \dots, f_s\}$ using the multivariate division algorithm, the resulting polynomial $r$ is written as $\text{reduce}(h, F)$ and is said that $h$ reduces to $r$.
\end{definition}

\begin{algorithm}[H]
\caption{Multivariate Division Algorithm} 
\label{alg:mult_polydivision}
\begin{algorithmic}
\Require $h, F=\{f_1, \dots, f_s\}, >$
\Ensure $r$
\State $p \gets h, r \gets 0$
\While{$p \neq 0$}
    \If{$\exists i$ s.t. $LT(f_i) \mid LT(p)$}
        \State $p \gets p - \frac{LT(p)}{LT(f_i)} f_i$
    \Else
        \State $r \gets r + LT(p), \enspace p \gets p - LT(p)$
    \EndIf
\EndWhile \ and \Return $r$
\end{algorithmic}
\end{algorithm}

We denote the result of this process as $r = \text{reduce}(h, F)$. If $\text{reduce}(h, F) = 0$, we have explicitly constructed coefficients $a_i$ such that $h = \sum a_i f_i$, proving that $h \in I$. However, unlike the univariate case, a non-zero remainder does \textit{not} prove that $h \notin I$. The output of the division algorithm depends heavily on the order in which the divisors $f_i$ are listed.

To demonstrate this, let us apply Algorithm \ref{alg:mult_polydivision} to Example \ref{ex:multivar_membership}, using the Lexicographic order with $x > y$. In this example, $f_1 = x^2 y - x$ and $f_2 = x^2 + y^3$, and we want to check if $h = x^2 y + y^4$ is in the ideal $I$. First, we list the divisors as $I = \langle f_1, f_2 \rangle$, so the algorithm checks $f_1$ first. In this case, the final result is $r = x + y^4 \neq 0$, suggesting that $h \notin I$. If we then list the divisors as $I = \langle f_2, f_1 \rangle$. The algorithm checks $f_2$ first, in which case the final result is $r = 0$, indicating that $h \in I$. Since we found a remainder of 0 in the second case, we have proven that $h \in I$. This example highlights that the standard multivariate division algorithm is not sufficient for the ideal membership problem because the remainder is not unique. Have in mind, that this is a simple example with only two generators, and in practice, ideals can have many generators and the orderings can be much more complex.

The failure of the division algorithm arises because the leading terms of the generators $\{f_1, \dots, f_s\}$ may not cover all the leading terms of the ideal $I$. Cancellation can occur between generators during linear combination, producing a new polynomial in $I$ with a leading term not divisible by any $\text{LT}(f_i)$. To resolve this, we could try to start the division process with a divisor that is an element of $I$ itself. However if the leading term of this element is not divisible by any $\text{LT}(f_i)$, we cannot proceed with the division. Thus, we need a generating set of $I$ such that every element of $I$ has its leading term divisible by some leading term of the generating set. A Gröbner basis is a generating set with this property.

\begin{definition}[Gröbner Basis]
\label{def:grobner_basis}
Let there be a fixed monomial order. A finite subset of generators $G = \{g_1, \dots, g_t\} \subset I$ is a Gröbner basis for a non-zero ideal $I$ if 
\[
\langle \text{LT}(g_1), \dots, \text{LT}(g_t) \rangle = \langle \{ \text{LT}(f) \mid f \in I \} \rangle
\]
\end{definition}

This definition implies two equivalent properties that resolve the issues discussed above:
\begin{center}
    \begin{varwidth}{\textwidth}
        \begin{enumerate}[label=(\roman*), font=\itshape]
            \item $f \in I \iff \text{reduce}(f, G) = 0$
            \item $\text{reduce}(f, G)$ is unique $\forall f \in R$ regardless of the order of $g_i$.
        \end{enumerate}
    \end{varwidth}
\end{center}

Property (i) directly answers Example \ref{ex:multivar_membership}, as if we could find a Gröbner basis $G$ for $I$, we could simply compute $\text{reduce}(h_3, G)$ to determine if $h_3 \in I$ without taking account of the order of generators. Property (ii) ensures that the multivariate division algorithm behaves consistently when using a Gröbner basis, making it a reliable tool for computations in polynomial ideals. This consistency and reliability makes Gröbner bases a widely used tool in computational algebraic geometry and computer algebra systems.

\section{Buchberger's Algorithm}

While the existence of Gröbner bases is theoretically guaranteed, their practical utility depends on our ability to compute them explicitly. In 1965, Bruno Buchberger introduced the fundamental algorithm for constructing these bases in \cite{Buchberger1965_algorithmGerman,Buchberger1965_algorithmEnglish}. The core of his method relies on detecting and repairing "ambiguities" where the multivariate division algorithm fails to be unique.

The primary obstruction to uniqueness in multivariate division is the cancellation of leading terms. If we have two polynomials $f, g \in I$, it is possible that a linear combination $af + bg$ causes the leading terms to cancel, revealing a new leading term of lower order that was previously hidden. Buchberger identified that we do not need to check all random linear combinations. We only need to check the minimal cancellation between the leading terms of pairs of generators.

\begin{definition}[S-Polynomial]
\label{def:s_polynomial}
Let $f, g \in k[x_1, \dots, x_n]$ be non-zero polynomials. Let $x^\gamma = \text{lcm}(\text{LM}(f), \text{LM}(g))$ be the least common multiple of their leading monomials. The S-polynomial of $f$ and $g$ is defined as
\[
S(f, g) = \frac{x^\gamma}{\text{LT}(f)} \cdot f - \frac{x^\gamma}{\text{LT}(g)} \cdot g
\]
\end{definition}

The $S$-polynomial is constructed specifically to cancel the leading terms of $f$ and $g$. It is very likely that this cancellation reveals a new leading term in the ideal that is not divisible by either $\text{LT}(f)$ or $\text{LT}(g)$. In other words, if this cancellation results in a polynomial that cannot be reduced to zero by the current set of generators \footnote{It is fascinating that the $S$-polynomial reveals all potential ambiguities or problems with a generating set.}, we have found a new polynomial that needs to be added to our generating set to ensure it covers all leading terms of the ideal.

Now suppose $f \in I$, then by Definition \ref{def:ideal}, $f$ can be expressed as
\[ f = \sum_{i=1}^{s} a_i g_i \]
for some $a_i \in R$ and $g_i \in G$. Observe that each term in this sum has a lead term $\text{LT}(a_i g_i) = \text{LT}(a_i) \text{LT}(g_i)$, which is divisible by $\text{LT}(g_i)$. The only way that $f$ has a leading term not divisible by any $\text{LT}(g_i)$ is if there is cancellation among these leading terms. We can trace this cancellation back to pairs of generators $g_i, g_j$ whose leading terms cancel in the sum. The minimal such cancellation is exactly the $S$-polynomial $S(g_i, g_j)$, and since by assumption $f \in I$, we must have $S(g_i, g_j) \in I$ as well. Therefore, if $G$ is a Gröbner basis, by property \textit{(i)} of Definition \ref{def:grobner_basis}, we must have $\text{reduce}(S(g_i, g_j), G) = 0$ for all pairs $i, j$. Conversely, if this condition holds for all pairs, then any polynomial $f \in I$ cannot have a leading term that escapes divisibility by some $\text{LT}(g_i)$, because any such escape would trace back to a non-zero remainder from some $S$-polynomial. This leads us to Buchberger's Criterion.


\begin{theorem}[Buchberger's Criterion]
\label{thm:buchberger_criterion}
Let $G = \{g_1, \dots, g_t\}$ be a generating set for an ideal $I$. Then $G$ is a Gröbner basis for $I$ if and only if:
\[
\text{reduce}(S(g_i, g_j), G) = 0
\]
for all pairs $1 \le i < j \le t$.
\end{theorem}

This theorem transforms the definition of a Gröbner basis from an abstract property about infinite sets (all polynomials in $I$) into a finite computational check.

Buchberger's algorithm is a direct application of the criterion above. We start with an arbitrary generating set and iteratively check S-polynomials. If an S-polynomial has a non-zero remainder, we add that remainder to our generating set. This expands the set of leading terms, allowing us to reduce more polynomials.

\begin{algorithm}[H]
\caption{Buchberger's Algorithm}
\begin{algorithmic}[1]
\Require Generating set $F = \{f_1, \dots, f_s\}$
\Ensure A Gröbner basis $G$ for $\langle F \rangle$
\State $G \leftarrow F$
\State $P \leftarrow \{(f_i, f_j) \mid f_i, f_j \in G, f_i \neq f_j\}$
\While{$P \neq \emptyset$}
    \State Select and remove a pair $(f, g)$ from $P$
    \State $S \leftarrow S(f, g)$
    \State $r \leftarrow \text{reduce}(S, G)$
    \If{$r \neq 0$}
        \State $P \leftarrow P \cup \{(r, h) \mid h \in G\}$
        \State $G \leftarrow G \cup \{r\}$
    \EndIf
\EndWhile
\State \Return $G$
\end{algorithmic}
\end{algorithm}

Termination is guaranteed by the Ascending Chain Condition (ACC) on polynomial ideals. Each time we add a non-zero remainder $r$, its leading ideal $\langle \text{LT}(r) \rangle$ is strictly larger than the previous leading ideal. Since $k[x_1, \dots, x_n]$ is a Noetherian ring, this chain of ideals cannot grow strictly strictly forever.

\subsection{Minimal and Reduced Bases}

The output of Buchberger's algorithm often contains redundant elements. For example, if we have generators $x^2$ and $x^3$, the $x^3$ is unnecessary because anything reducible by $x^3$ is already reducible by $x^2$. To optimize the basis, we apply two stages of cleaning.

\begin{definition}[Reduced Gröbner Basis]
A Gröbner basis $G$ is \textbf{reduced} if:
\begin{enumerate}
    \item For every $g \in G$, $\text{LC}(g) = 1$ (monic).
    \item For every $g \in G$, no monomial appearing in $g$ is divisible by any $\text{LT}(h)$ for $h \in G \setminus \{g\}$.
\end{enumerate}
\end{definition}

While a specific ideal can have many different Gröbner bases (depending on the algorithm's choices), the \textit{reduced} Gröbner basis is unique for a fixed monomial order.

\begin{example}
Consider $I = \langle f_1, f_2 \rangle \subseteq \mathbb{Q}[x, y]$ with lex order ($x > y$), where:
\[ f_1 = x^2 + y, \quad f_2 = xy + x \]
\textbf{Step 1:} Calculate $S(f_1, f_2)$.
The lcm of $x^2$ and $xy$ is $x^2y$.
\begin{align*}
S(f_1, f_2) &= y(x^2 + y) - x(xy + x) \\
&= (x^2y + y^2) - (x^2y + x^2) \\
&= y^2 - x^2
\end{align*}
In lex order, $-x^2$ is the leading term. We reduce this against $G$. Since $f_1 = x^2 + y$, we can eliminate $-x^2$:
\[
r = (y^2 - x^2) + f_1 = y^2 - x^2 + (x^2 + y) = y^2 + y
\]
This remainder $r = y^2 + y$ is not divisible by $x^2$ or $xy$. Thus, $r \neq 0$, and we must append it to the basis.
\[ G = \{x^2 + y, \; xy + x, \; y^2 + y\} \]

\textbf{Step 2:} We would now process new pairs involving $f_3 = y^2 + y$.
For instance, $S(f_2, f_3)$ eventually reduces to $0$. Upon checking all pairs, we confirm $G$ is a Gröbner basis.

\textbf{Step 3:} Reduce the basis.
Notice that $\text{LT}(f_2) = xy$. However, $f_2 = x(y+1)$, and since $y^2+y = y(y+1)$, careful reduction (or variable substitution) reveals redundancies. The fully reduced basis for this ideal turns out to be simply:
\[ G_{reduced} = \{ x, y \} \]
This example highlights how the raw algorithm may produce complex intermediate outputs for effectively simple ideals.
\end{example}

\section{Improvements to Buchberger's Algorithm}

\subsection{Pair Elimination}

\subsection{Selection Strategies}

\subsection{Signature-Based Algorithms}

\subsection{Symbolic Pre-processing}

\section{Complexity and Performance Metrics}